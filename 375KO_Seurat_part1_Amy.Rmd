---
title: "miR-375 KO (baseline)"
subtitle: "Part2: scRNA-seq clustering"
author: "Amy Hung"
date: "Last compiled on `r format(Sys.time(), '%d %B %Y')`"
output:
  rmdformats::robobook:
    thumbnails: true
    lightbox: true
    gallery: true
    code_folding: show
---

```{r setup, include=FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir='/home/yah6/2022_04_375KO-12m_reanalysis/rmarkdown')
```

## Sample description

This is the single cell RNAseq data of two 375KO mice and two WT mice (generated by 10X Genomics Chromium platform - 3' V2 kit). Samples were jejunal crypts isolated from sex and age matched 375KO and WT mice (male; 12m old; chow diet condition).

-   Set 1 contained one 375KO and one WT mice processed in April 2019.

-   Set 2 contained one 375KO and one WT mice processed in October 2019.

------------------------------------------------------------------------

## Load required libraries

```{r load-libraries, message = FALSE, warning= FALSE, error=FALSE}
library(stringr)
library(Seurat, lib.loc = "/programs/R-4.0.5/library")
library(tidyverse)
library(openxlsx)
library(scDblFinder)
library(BiocParallel)
library(glmGamPoi)

```

## Load soupx output into Seurat objects

```{r load-data}
set.seed(1234)

proj_name <- "375KO-12m"

##Setup the Seurat objects

# Load the counts matricies into separate datasets
wt.data <- Read10X(data.dir = "/home/yah6/2022_04_375KO-12m_reanalysis/soupx_WT_filt/")
ko.data <- Read10X(data.dir = "/home/yah6/2022_04_375KO-12m_reanalysis/soupx_KO_filt/")
wt2.data <- Read10X(data.dir = "/home/yah6/2022_04_375KO-12m_reanalysis/soupx_WT2_filt/")
ko2.data <- Read10X(data.dir = "/home/yah6/2022_04_375KO-12m_reanalysis/soupx_KO2_filt/")

# check for duplicated barcodes(column names) within a dataset
any(duplicated(x = colnames(x = wt.data)))
any(duplicated(x = colnames(x = ko.data)))
any(duplicated(x = colnames(x = wt2.data)))
any(duplicated(x = colnames(x = ko2.data)))

# Rename columns to avoid trouble when merging data sets (since identical columns between KO and WT)
colnames(x = wt.data) <- paste('WT', colnames(x = wt.data), sep = '_')
colnames(x = ko.data) <- paste('375KO', colnames(x = ko.data), sep = '_')
colnames(x = wt2.data) <- paste('WT2', colnames(x = wt2.data), sep = '_')
colnames(x = ko2.data) <- paste('375KO2', colnames(x = ko2.data), sep = '_')

### Initialize the Seurat object with the raw, non-normalized data
# Keep all genes expressed in >= 3 cells. 
# Keep all cells with at least 200 detected genes.
wt <- CreateSeuratObject(counts = wt.data, 
                            min.cells = 3, 
                            min.features = 200, 
                            project = "WT")
ko <- CreateSeuratObject(counts = ko.data, 
                            min.cells = 3, 
                            min.features = 200, 
                            project = "375KO")
wt2 <- CreateSeuratObject(counts = wt2.data, 
                            min.cells = 3, 
                            min.features = 200, 
                            project = "WT2")
ko2 <- CreateSeuratObject(counts = ko2.data, 
                            min.cells = 3, 
                            min.features = 200, 
                            project = "375KO2")


### add treatment/group status to objects
# add group
wt[["group"]] <- "WT"
ko[["group"]] <- "375KO"
wt2[["group"]] <- "WT"
ko2[["group"]] <- "375KO"

# add individual mouse ID
wt[["mouse"]] <- "WT-1"
ko[["mouse"]] <- "375KO-1"
wt2[["mouse"]] <- "WT-2"
ko2[["mouse"]] <- "375KO-2"

wt #4853
ko #5095
wt2 #1206
ko2 #1245
```

## Doublet detection

Cell doublets were identified using [scDblFinder](https://bioconductor.org/packages/release/bioc/vignettes/scDblFinder/inst/doc/introduction.html), which uses functions from various other doublet detection methods, but has been rewritten to be more compute efficient. A comparison between other methods and scDblFinder can be found in [Xi and Li](https://arxiv.org/pdf/2101.08860.pdf). In this method, doublets are detected through the introduction of pseudo-doublets by combining two random cells. A nearest-neighbor approach is then employed to see which cells associate most closely with these pseudo-doublets. The percent of cells called as doublets is based on 10x genomics known doublet rate.

*Notes*: I had used the codes below to generate singlet flat file in April 2022. For rendering purpose, I set eval = F for the block and then load pre-existing data in the next code chunk.

```{r scDblFinder-doublet-detection, cache = T, eval= FALSE}
set.seed(1234)

# Merge datasets into one single seurat object
alldata <- merge(wt, c(wt2, ko, ko2))

# Convert to single cell experiment
sce <- as.SingleCellExperiment(alldata)

# Run scDoubletFinder
bp <- MulticoreParam(3, RNGseed=1234)  # this ensures reproducibility when multithreading
bpstart(bp)
sce <- scDblFinder(sce, 
                   samples="group", 
                   BPPARAM=bp)
bpstop(bp)


# If the code above doesn't work, unhash and try this.
# sce <- scDblFinder(sce,
#                    samples="sample",
#                    BPPARAM=MulticoreParam(3))

# Quick check of the results
table(sce$scDblFinder.class) # singlet 11697, doublet 702

# Write out metadata of doublet scores to flat file 
sce@colData %>%
  as.data.frame() %>%
  rownames_to_column(var = "cell_id") %>%
  dplyr::select(cell_id, contains("scDblFinder")) 
  write_csv(paste0(proj_name, "_scDbtFinder_metadata.csv"))

# Get cell ID that are defined as singlet
sce_sub <- subset(sce, ,scDblFinder.class == "singlet")
table(sce_sub$scDblFinder.class)
singlet_cell_id <- colnames(sce_sub)
```

## Doublet detection - load data

```{r scDblFinder-load-data}
# Load doublet metadata sheet
mdata <- read.csv("/home/yah6/2022_04_375KO-12m_reanalysis/375KO-12m_scDbtFinder_metadata_R1.csv")

# Quick check 
nrow(mdata) #12399
nrow(filter(mdata, scDblFinder.class =="singlet")) #11697
nrow(filter(mdata, scDblFinder.class =="doublet")) #702

# Get cell ID that are defined as singlet
singlet_cell_id <- as.vector(mdata$cell_id[which(mdata$scDblFinder.class =="singlet")])
```

## QC and filtering

*Notes*: **nFeature_RNA** is the number of unique genes detected per cell; **nCount_RNA** is the number of unique UMI molecules per cell; **percentage.mt** is the percentage of mitochondria genes per cell (indicating apoptotic cells).

Based on the resulting QC plots, I chose nFeature_RNA greater than 1500 & percent.mt smaller than 25% as the cutoff for the downstream analyses.

```{r qc-and-filtering, fig.width = 8, fig.height = 16}
set.seed(1234)

# List all samples for looping function 
obj.list <- list(wt,
                 wt2,
                 ko,
                 ko2)

# Remove cells classified as doublets by scDblFinder
for (i in 1:length(obj.list)) {
  print(obj.list[[i]]@project.name)
  print(paste0("Number of cells: ", ncol(obj.list[[i]])))
  obj.list[[i]] <- obj.list[[i]][,intersect(colnames(obj.list[[i]]), singlet_cell_id)]
  print(paste0("Number of cells: ", ncol(obj.list[[i]])))
  print(" ")
}

# Add % of reads mapping to mitochondrial genes
for (i in 1:length(obj.list)) {
  obj.list[[i]] <- PercentageFeatureSet(obj.list[[i]], pattern = "^mt-", col.name = 'percent.mt') 
  obj.list[[i]][["per.mito.bin"]] <- ifelse(obj.list[[i]][["percent.mt"]] > 20, "> 20%", ifelse(obj.list[[i]][["percent.mt"]] > 10, "10%-20%", ifelse(obj.list[[i]][["percent.mt"]] > 2.5, "2.5%-10%", "< 2.5%")))
}

# Visualize QC metrics as a violin plot (hide individual data points)
plts <- lapply(obj.list, function(x) VlnPlot(x, 
                                             features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
                                             group.by = "group",
                                             pt.size = 0,
                                             ncol = 3))

patchwork::wrap_plots(plts, ncol = 1)
ggsave(paste0(proj_name, "_QC_no-pts.png"), units = "in", width = 8, height = 4 * length(obj.list), dpi = 300)

# Visualize QC metrics as a violin plot (show individual data points)
plts <- lapply(obj.list, function(x) VlnPlot(x, 
                                             features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), 
                                             group.by = "group",
                                             pt.size = 0.25,
                                             ncol = 3))

patchwork::wrap_plots(plts, ncol = 1)
ggsave(paste0(proj_name, "_QC.png"), units = "in", width = 8, height = 4 * length(obj.list), dpi = 300)

# Subset loop
for (i in 1:length(obj.list)) {
  print(obj.list[[i]]@project.name)
  print(paste0("Number of cells: ", ncol(obj.list[[i]])))
  obj.list[[i]] <- subset(obj.list[[i]], subset = nFeature_RNA > 1500 & percent.mt < 25)
  print(paste0("Number of cells: ", ncol(obj.list[[i]])))
  print(" ")
}

```

## SC Transform 

The step to get "normalized counts". The latest version of sctransform also supports using glmGamPoi package which substantially improves the speed of the learning procedure. It can be invoked by specifying `method="glmGamPoi"`.

```{r sctransform, cache=T, message=F}
set.seed(1234)

obj.list <- lapply(X = obj.list, FUN = function(x) {
    x <- SCTransform(x, 
                     method = "glmGamPoi", 
                     assay = "RNA",
                     new.assay.name = "SCT")
})

features <- SelectIntegrationFeatures(object.list = obj.list, nfeatures = 3000)
obj.list <- PrepSCTIntegration(object.list = obj.list, anchor.features = features)

integration.anchors <- FindIntegrationAnchors(object.list = obj.list, normalization.method = "SCT", anchor.features = features)
seurat_obj <- IntegrateData(anchorset = integration.anchors, normalization.method = "SCT")
```

## Clustering and visualization

The Seurat SCT vignette states that 30 PCs should be used, as this will increase performance. Defining number of cell clusters - `FindClusters` function was performed to generate UMAPs with different clustering resolution (from 0.1 to 1.5). I chose resolution = 0.7 as the proper clustering resolution.\
This code chunk also write an RDS file that include data from only "singlet" cells.

```{r clustering, message=F}
set.seed(1234)

# Run the standard workflow for visualization and clustering
seurat_obj <- RunPCA(seurat_obj)
seurat_obj <- RunUMAP(seurat_obj, reduction = "pca", dims = 1:30)

seurat_obj <- FindNeighbors(seurat_obj, reduction = "pca", dims = 1:30)

# Create a sub-folder to store all the resolution iterations for clustering 
dir.create("res_iter")

for (i in seq(.1, 1.5, by = .1)) {
  seurat_obj_tmp <- FindClusters(seurat_obj, resolution = i)
  DimPlot(seurat_obj_tmp, reduction = "umap", label = T)
  ggsave(paste0("res_iter/", proj_name, '_res-iter_', i, '_umap.png'), units = 'in', width = 6, height = 5, dpi = 250)
}

# Choose a proper resolution level 
seurat_obj <- FindClusters(seurat_obj, resolution = 0.7)

# Set default assay to RNA
DefaultAssay(seurat_obj) <- "RNA"
seurat_obj <- NormalizeData(seurat_obj)
seurat_obj <- ScaleData(seurat_obj)

saveRDS(seurat_obj, paste0(proj_name, '_seurat-obj.rds'))
```

## UMAP plots

```{r UMAP-plot, fig.width=12, fig.height=5}
# UMAP by cell cluster ID
plt1 <- DimPlot(seurat_obj, reduction = "umap", label = T)

# UMAP by mouse groups (KO vs WT)
plt2 <- DimPlot(seurat_obj, reduction = "umap", group.by = "group")

plt1 | plt2
ggsave(paste0(proj_name, '_umap.png'), units = 'in', width = 12, height = 5, dpi = 250)
```

## Overlain UMAP with other metadata info

```{r UMAP-extra-metrics, fig.width=12, fig.height=10}

# Cell cycling scores
seurat_obj <- CellCycleScoring(
    seurat_obj,
    s.features = str_to_title(cc.genes$s.genes),
    g2m.features = str_to_title(cc.genes$g2m.genes),
    assay = 'SCT',
    set.ident = TRUE
  )
Idents(seurat_obj) <- "seurat_clusters"

# Plot metadata
plt1 <- DimPlot(seurat_obj, reduction = "umap", label = T)
plt2 <- DimPlot(seurat_obj, reduction = "umap", group.by = "group")
plt3 <- DimPlot(seurat_obj, reduction = "umap", group.by = "per.mito.bin")
plt4 <- DimPlot(seurat_obj, reduction = "umap", group.by = "Phase")
(plt1 | plt2) / (plt3 | plt4 )
ggsave(paste0(proj_name, '_umap_other-meta.png'), units = 'in', width = 12, height = 10, dpi = 250)
```

## Cell abundances

Simply determine the proportion of WT and KO cells for each of the cluster.

```{r cell-abundances}

# Find cell #/% in each cluster and write output
count_per_cluster <- table(Idents(seurat_obj), seurat_obj@meta.data$group)
percent_per_cluster <- prop.table(table(Idents(seurat_obj), seurat_obj@meta.data$group), margin = 2)

count_per_cluster
percent_per_cluster

# plotting (% as for the entire dataset)
as.data.frame(percent_per_cluster) %>%
  mutate(Percent = Freq * 100,
         Cluster = Var1,
         Condition = Var2) %>%
  ggplot(., aes(Cluster, Percent, fill = Condition)) +
  geom_bar(stat = 'identity', position = 'dodge') +
  theme_classic()
  ggsave(paste0(proj_name, '_percent_cell_in_cluster.png'), width = 8, height = 6)

# plotting (% within a given cluster)
as.data.frame(prop.table(table(Idents(seurat_obj), seurat_obj@meta.data$group), margin = 1)) %>%
    mutate(Percent = Freq * 100,
         Cluster = Var1,
         Condition = Var2) %>%
  ggplot(., aes(Cluster, Percent, fill = Condition)) +
  geom_bar(stat = 'identity') +
  theme_classic()
  ggsave(paste0(proj_name, '_percent_sample_in_cluster.png'), width = 8, height = 6)

# write output 
wb=createWorkbook()
ws=addWorksheet(wb,'Cells per cluster')
writeData(wb, ws, count_per_cluster, rowNames = F, colNames = T, startRow = 1,startCol = 1)
ws=addWorksheet(wb,'Percent per cluster')
writeData(wb, ws, percent_per_cluster, rowNames = F, colNames = T, startRow = 1,startCol = 1)
saveWorkbook(wb, paste0(proj_name, '_cells_per_cluster.xlsx'), overwrite = T)
```

## Session info

```{r session-info}

sessionInfo()

```
